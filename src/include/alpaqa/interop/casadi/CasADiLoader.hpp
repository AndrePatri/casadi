#pragma once

#include <alpaqa/casadi-loader-export.hpp>
#include <alpaqa/config/config.hpp>
#include <alpaqa/problem/dynamics.hpp>
#include <alpaqa/problem/type-erased-problem.hpp>

#include <memory>
#include <string>
#include <type_traits>

namespace alpaqa {

namespace detail {

template <class T>
struct copyable_unique_ptr {
    copyable_unique_ptr(std::unique_ptr<T> ptr) : ptr{std::move(ptr)} {}
    copyable_unique_ptr() = default;
    copyable_unique_ptr(const copyable_unique_ptr &o)
        : ptr{o.ptr ? std::make_unique<T>(*o.ptr) : nullptr} {}
    copyable_unique_ptr &operator=(const copyable_unique_ptr &o) {
        this->ptr = o.ptr ? std::make_unique<T>(*o.ptr) : nullptr;
        return *this;
    }
    copyable_unique_ptr(copyable_unique_ptr &&)            = default;
    copyable_unique_ptr &operator=(copyable_unique_ptr &&) = default;

    operator std::unique_ptr<T> &() & { return ptr; }
    operator const std::unique_ptr<T> &() const & { return ptr; }
    operator std::unique_ptr<T> &&() && { return std::move(ptr); }

    std::unique_ptr<T> &operator->() { return ptr; }
    const std::unique_ptr<T> &operator->() const { return ptr; }

    std::unique_ptr<T> ptr;
};

} // namespace detail

namespace casadi_loader {
template <Config>
struct CasADiFunctionsWithParam;
} // namespace casadi_loader

/// Problem definition for a CasADi problem, loaded from a DLL.
/// @ingroup grp_Problems
template <Config Conf = DefaultConfig>
class CasADiProblem : public BoxConstrProblem<Conf> {
  public:
    USING_ALPAQA_CONFIG(Conf);
    vec param;

    /// Load a problem generated by CasADi (with parameters).
    ///
    /// @param  filename
    ///         Filename of the shared library to load the functions from.
    /// @param  n
    ///         Number of decision variables (@f$ x \in \R^n @f$).
    /// @param  m
    ///         Number of general constraints (@f$ g(x) \in \R^m @f$).
    /// @param  p
    ///         The number of parameters of the problem (second argument to all
    ///         CasADi functions).
    /// @param  second_order
    ///         Load the additional functions required for second-order PANOC.
    ///
    /// The file should contain functions with the names `f`, `grad_f`, `g` and
    /// `grad_g`. These functions evaluate the objective function, its gradient,
    /// the constraints, and the constraint gradient times a vector respecitvely.
    /// If @p second_order is true, additional functions `hess_L` and
    /// `hess_L_prod` should be provided to evaluate the Hessian of the
    /// Lagrangian and Hessian-vector products.
    ///
    /// If any of the dimensions are less than or equal to zero, they are
    /// determined from the `g` function in the given file.
    ///
    /// @throws std::invalid_argument
    ///         The dimensions of the loaded functions do not match.
    CasADiProblem(const std::string &filename, length_t n = 0, length_t m = 0,
                  length_t p = 0, bool second_order = false);
    ~CasADiProblem();

    CasADiProblem(const CasADiProblem &);
    CasADiProblem &operator=(const CasADiProblem &);
    CasADiProblem(CasADiProblem &&);
    CasADiProblem &operator=(CasADiProblem &&);

    // clang-format off
    real_t eval_f(crvec x) const;
    void eval_grad_f(crvec x, rvec grad_fx) const;
    void eval_g(crvec x, rvec g) const;
    void eval_grad_g_prod(crvec x, crvec y, rvec grad_gxy) const;
    void eval_grad_ψ(crvec x, crvec y, crvec Σ, rvec grad_ψ, rvec work_n, rvec work_m) const;
    real_t eval_ψ_grad_ψ(crvec x, crvec y, crvec Σ, rvec grad_ψ, rvec work_n, rvec work_m) const;
    void eval_grad_L(crvec x, crvec y, rvec grad_L, rvec work_n) const;
    real_t eval_ψ(crvec x, crvec y, crvec Σ, rvec ŷ) const;
    void eval_grad_ψ_from_ŷ(crvec x, crvec ŷ, rvec grad_ψ, rvec work_n) const;
    void eval_grad_gi(crvec x, index_t i, rvec grad_i) const;
    void eval_hess_L_prod(crvec x, crvec y, crvec v, rvec Hv) const;
    void eval_hess_L(crvec x, crvec y, rmat H) const;
    // clang-format on

    /// @see @ref TypeErasedProblem::provides_eval_grad_gi
    bool provides_eval_grad_gi() const;
    /// @see @ref TypeErasedProblem::provides_eval_hess_L_prod
    bool provides_eval_hess_L_prod() const;
    /// @see @ref TypeErasedProblem::provides_eval_hess_L
    bool provides_eval_hess_L() const;

  private:
    using Functions = casadi_loader::CasADiFunctionsWithParam<Conf>;
    std::unique_ptr<Functions> impl;
};

CASADI_LOADER_EXPORT_EXTERN_TEMPLATE(class, CasADiProblem, EigenConfigd);
CASADI_LOADER_EXPORT_EXTERN_TEMPLATE(class, CasADiProblem, DefaultConfig);

namespace casadi_loader {
template <Config>
struct CasADiControlFunctionsWithParam;
} // namespace casadi_loader

template <Config Conf>
class CasADiControlProblem {
  public:
    USING_ALPAQA_CONFIG(Conf);
    using Box = alpaqa::Box<config_t>;
    length_t N, nx, nu;
    vec x_init;
    vec param;
    Box U;
    CostStructure cost_structure = CostStructure::General;

    CasADiControlProblem(const std::string &filename, length_t N,
                         length_t nx = 0, length_t nu = 0, length_t p = 0);
    ~CasADiControlProblem();

    CasADiControlProblem(const CasADiControlProblem &);
    CasADiControlProblem &operator=(const CasADiControlProblem &);
    CasADiControlProblem(CasADiControlProblem &&);
    CasADiControlProblem &operator=(CasADiControlProblem &&);

    void get_U(Box &U) const { U = this->U; }
    void get_x_init(rvec x_init) const { x_init = this->x_init; }
    void eval_f(index_t timestep, crvec x, crvec u, rvec fxu) const;
    void eval_jac_f(index_t timestep, crvec x, crvec u, rmat J_fxu) const;
    real_t eval_l(index_t timestep, crvec h) const;
    real_t eval_l_N(crvec h) const;
    void eval_grad_l(index_t timestep, crvec h, rvec grad_lh) const;
    void eval_grad_l_N(crvec h, rvec grad_lh) const;
    void eval_hess_l(index_t timestep, crvec h, rmat hess_lh) const;
    void eval_hess_l_N(crvec h, rmat hess_lh) const;
    CostStructure get_l_structure() const { return cost_structure; }
    void check() const {} // TODO

    length_t get_N() const { return N; }
    length_t get_nx() const { return nx; }
    length_t get_nu() const { return nu; }
    length_t get_nh() const { return nx + nu; }

  private:
    using Functions = casadi_loader::CasADiControlFunctionsWithParam<Conf>;
    detail::copyable_unique_ptr<Functions> impl;
};

CASADI_LOADER_EXPORT_EXTERN_TEMPLATE(class, CasADiControlProblem, EigenConfigd);
CASADI_LOADER_EXPORT_EXTERN_TEMPLATE(class, CasADiControlProblem,
                                     DefaultConfig);

} // namespace alpaqa